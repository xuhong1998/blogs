<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="fugmdnw@qq.com"><title>前端模块化 · 徐宏</title><meta name="description" content="commonJS因为在网页端即使没有模块化，JavaScript也可以工作下去，只是逻辑更加复杂。但在服务端一定要有模块，所以JavaScript第一个流行起来的模块化标准是服务端应用带来的。nodeJS采用了commonJS模块规范。
语法
暴露模块：module.exports = value "><meta name="keywords" content="xuhong"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/blogs/css/style.css"><link rel="stylesheet" href="/blogs/css/blog_basic.css"><link rel="stylesheet" href="/blogs/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/blogs/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">徐宏</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/u/5070036541/home?wvr=5&amp;uut=fin&amp;from=reg"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/xuhong1998"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="https://github.com/xuhong1998/img-folder/blob/master/changda/favicon.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>前端模块化</a></h3></div><div class="post-content"><h2 id="commonJS"><a href="#commonJS" class="headerlink" title="commonJS"></a>commonJS</h2><p>因为在网页端即使没有模块化，JavaScript也可以工作下去，只是逻辑更加复杂。但在服务端一定要有模块，所以JavaScript第一个流行起来的模块化标准是服务端应用带来的。nodeJS采用了commonJS模块规范。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li><p>暴露模块：<font color="#e51c23">module.exports = value</font> 或 <font color="#e51c23">module.xxx = value</font></p>
</li>
<li><p>导入模块：<font color="#5e1c23">require(xxx)</font></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; reruen valeu + a&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="built_in">module</span>.exports.a = a</span><br><span class="line"><span class="built_in">module</span>.exports.add = add</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="keyword">const</span> example = <span class="built_in">require</span>(<span class="string">'./module.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(example.a, example.add(<span class="number">4</span>)) <span class="comment">// 5 11</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>所有的代码都运行在模块的作用域，不会污染全局函数。</li>
<li>模块加载的顺序是按照代码出现的顺序。</li>
<li>模块输入的是输出的值拷贝。也就是说一旦输出值，模块内部的变化就影响不到这个值了。</li>
</ul>
<h2 id="AMD-与-CMD"><a href="#AMD-与-CMD" class="headerlink" title="AMD 与 CMD"></a>AMD 与 CMD</h2><p>由于commonJS规范模块加载时同步的。只有加载完成才能执行后面的操作。在服务端很简单很自然，然而在浏览器端脚本标签时异步加载，commonJS在浏览器环境中无法正常加载。解决思路有需要在服务端对代码做静态分析，将模块与其他依赖一起返回给浏览器端，这种方法最大缺点就是需要在服务端安装额外组件。另外一种解决思路在另外弄一套模块标准来封装模块定义。</p>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">define(<span class="string">'module'</span>, [<span class="string">'dep1'</span>, <span class="string">'dep2'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>)</span>&#123; ... &#125;)</span><br><span class="line"><span class="comment">//加载</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'module'</span>, <span class="string">'./app'</span>] callback()) <span class="comment">//数组里面是要加载的模块, 第二个参数是加载成功的回调的函数。</span></span><br></pre></td></tr></table></figure>

<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>由于JavaScript原生不支持AMD， 因此使用AMD规范需要引入RequireJS</p>
<ul>
<li>requireJS 首先检查依赖模块，根据配置文件，获取js文件实际的地址。</li>
<li>根据js文件实际路径，在DOM中插入script标签，并且绑定onload事件获取模块加载完通知。</li>
<li>当script全部调用完，调用回调函数。</li>
</ul>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴露模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">7</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">vallue</span>) =&gt;</span> &#123; <span class="keyword">return</span> value + a &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; a, add &#125; <span class="keyword">from</span> <span class="string">'./app'</span></span><br><span class="line"><span class="built_in">console</span>.log(a, add(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li>
<li>ES6 模块设计思想：尽量的静态化、使得编译时就能确定模块的依赖关系，以及输入和输出的变量（CommonJS和AMD模块，都只能在运行时确定这些东西）。</li>
</ul>
<h2 id="ES6-与-commonJS-区别"><a href="#ES6-与-commonJS-区别" class="headerlink" title="ES6 与 commonJS 区别"></a>ES6 与 commonJS 区别</h2><ul>
<li><p>ccommonJS</p>
<ul>
<li>对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。</li>
<li>对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。</li>
<li>当使用require命令加载某个模块时，就会运行整个模块的代码。</li>
<li>当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</li>
<li>循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</li>
</ul>
</li>
<li><p>ES6 模块</p>
<ul>
<li>ES6模块中的值属于【动态只读引用】。</li>
<li>对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li>
<li>对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。</li>
<li>循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。</li>
</ul>
</li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-12-19</span><i class="fa fa-tag"></i><a class="tag" href="/blogs/tags/模块化/" title="-模块化">-模块化 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://xuhong1998.github.io/blogs/2020/12/19/前端模块化/,徐宏,前端模块化,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/blogs/2021/06/19/for in 与 for of 的区别/" title="javaScript二叉树">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/blogs/2020/07/03/this/" title="this">Próximo post</a></li></ul></div></div></div></div></div><script src="/blogs/js/jquery.js"></script><script src="/blogs/js/jquery-migrate-1.2.1.min.js"></script><script src="/blogs/js/jquery.appear.js"></script></body></html>